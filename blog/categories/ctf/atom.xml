<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ctf | Hello (forgotten) world]]></title>
  <link href="http://tech.aquarite.info/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://tech.aquarite.info/"/>
  <updated>2014-03-04T03:43:51+09:00</updated>
  <id>http://tech.aquarite.info/</id>
  <author>
    <name><![CDATA[Mei Akizuru]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SECCON 2013 全国大会 フラグワード取得]]></title>
    <link href="http://tech.aquarite.info/blog/2014/03/04/seccon-2013-final-auto-flagword/"/>
    <updated>2014-03-04T03:12:27+09:00</updated>
    <id>http://tech.aquarite.info/blog/2014/03/04/seccon-2013-final-auto-flagword</id>
    <content type="html"><![CDATA[<p>特定の問題ではなくてフラグワードの自動取得について。</p>

<p>スコアサーバーのフラグワードのページには、HTMLとしては外枠の、いわゆる<code>layout</code>の部分しかほとんど書いてない。アクセスするとJavaScriptが動いて、<a href="http://socket.io">Socket.IO</a>（中身はWebSocket）で配信サーバーに接続し、フラグワードが降ってきたらHTMLとして表示する、という処理が動いている。</p>

<p>そんなわけでスコアサーバーのフラグワードのページをGETで叩いても何も起きないのでWebSocketを使うことになる。あいにくと私自身がさっぱりJS書けないのとnode.jsの環境がチーム内のマシンにあるとも限らないのでRubyで書いた。</p>

<p>やることとしては<a href="https://rubygems.org/gems/socket.io-client-simple">socket.io-client-simple</a>を使ってサーバーに接続して、接続出来たら<code>flagwords</code>を送信する。すると<code>flagword</code>イベントが飛んでくるので、それを捕まえて自分のチームのフラグを取り出す。シンプル。</p>

<p>```
require &lsquo;socket.io-client-simple&rsquo;</p>

<p>module FlagWord
  SOCKET_URL = &lsquo;<a href="http://10.0.1.1:8000">http://10.0.1.1:8000</a>&rsquo;
  TEAM_NAME = &lsquo;urandom&rsquo;</p>

<p>  def self.get_flag</p>

<pre><code>flags = nil
socket = SocketIO::Client::Simple.connect SOCKET_URL
# handler
socket.on :connect do
  socket.emit :flagwords
end
socket.on :disconnect do
end
socket.on :flagword do |data|
  flags = data['flagwords']
end
# waiting for flags
until flags
  sleep 1
end
# return flag
idx = flags.find_index {|h| h['team_name'] == TEAM_NAME}
flags[idx]['flagword'].strip
</code></pre>

<p>  end
end</p>

<p>if <strong>FILE</strong> == $0
  puts FlagWord.get_flag
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SECCON 2013 全国大会 'Pisa']]></title>
    <link href="http://tech.aquarite.info/blog/2014/03/04/seccon-2013-final-pisa/"/>
    <updated>2014-03-04T02:16:24+09:00</updated>
    <id>http://tech.aquarite.info/blog/2014/03/04/seccon-2013-final-pisa</id>
    <content type="html"><![CDATA[<p>最初のkeyを見つけた後爆死していたというお話ですので答え合わせは別の方のwriteupをご覧ください（真顔）</p>

<p><code>pisa.tower/sec_bbs</code>というアドレスが提示されているのでとりあえずアクセスすると普通のWebページが見える。Sign inとかSign upとか書かれているし、<code>sec_bbs</code>だしBoardとかあるし、どうやら掲示板っぽい。</p>

<p>とりあえずSign upからアカウントを作成する。この後ログインすると掲示板に書き込めるようになる。ログイン辺りでSQLインジェクションを疑っていろいろ試したけどどうもそうでないらしい。</p>

<p>Boardに行くと書き込みフォームと書き込まれている内容が表示されている。書き込みの表示部分はJavaScriptで自動的に更新されている。書き込みフォームにはタイトルと本文の入力欄と、CAPTCHA認証がついている。どの入力欄も入力必須で、空欄で送信しようとするとクライアントサイドでのバリデーションに引っかかって送信できない。</p>

<p>FLAGページとして指定されているのは<code>/sec_bbs/api/message.json</code>で、ここを見ると（その拡張子通り）JSONデータが見られる。先ほどのBoardのページのソースコードもこのアドレスにリクエストを投げていたので、書き込んだ内容がJSON形式で得られるということらしい。ということは、掲示板にフラグワードを書き込めばよいということになる。</p>

<p>ブラウザを開いて根性でフラグワードを書き込み続けるのはアホらしいのでその辺を自動化するスクリプトを書いた。しかしながらCAPTCHA認証が存在するので完全な自動化はできない。そんなわけで、CAPTCHA画像の認識だけ人力で他を自動化するスクリプトを書いた。</p>

<p>そのスクリプトを書く上で、「一応ブラウザっぽくしておこう」と思ってFirebugでやりとりを見ていたところ、レスポンスヘッダに<code>Key</code>というフィールドが存在していて、そのフィールドに所定の形式でkeyが書かれていた。これが1つめのkey。（ちなみにこれチームメンバーがとっくに気がついていて送信済み）</p>

<p>さて、<code>csrf_token</code>と<code>cid</code>というCookieがセットされていて、それが毎度更新されているので、サーバーのレスポンスの<code>Set-Cookie</code>を見てそのようなCookieを用意し、かつパラメータにも<code>csrf_token</code>があるのでそんな感じでPOSTを投げるスクリプトを書いた。前述の「ブラウザっぽくリクエストする」を満たすためにFirefoxがリクエスト時に投げているリクエストとほぼ同等のものを投げるようにした。</p>

<p>余談だが、<code>/sec_bbs/board</code>で見える掲示板、タイトルや本文は書き込まれたテキストが<strong>マジでそのまま流れる</strong>ので、例えば<code>&lt;script&gt;alert('hoge')&lt;/script&gt;</code>と書けば'hoge'と書かれたダイアログが出る。ということは<code>location.href</code>なんかをごにょごにょすると表示した瞬間に別のページに飛ばされるように仕込むことができるわけで、実際そういう書き込みをしているチームがいた。これに対応するべくJavaScriptを無効化して見に行くと今度は<code>noscript</code>に<code>meta</code>要素が用意されていてこれで飛ばされる。Firefoxの場合meta要素によるリダイレクトもJavaScriptも設定で無効に出来るので、それらを無効にした状態で調査していた。</p>

<p>一応そんなスクリプトを用意してみたはいいもののやはり人手がかかるのはあまりにもアホらしいのでCAPTCHAをどうにかしようと思って調べたところ<a href="http://cintruder.sourceforge.net/">Captcha Intruder</a>が見つかった。どうにか本体と必要なライブラリを落としてきて（※会場内ではWiMAX回線が滅茶苦茶不安定）使ってみたものの認識不能。これ以上粘っても仕方ないだろうと思いその場は放置。リーダーから依頼されたフラグワードの自動取得スクリプトを書く方に移った。</p>

<p>フラグワード取得スクリプトを書き終えてしばらくしてからCAPTCHAの画像を収集して学習させればいいんじゃね、と思って、スクリプトの人力部分を弄って、入力した文字と画像を対応付けて保存するようにした。</p>

<p>そんな感じで一日目が終了した後、つくばに帰るTX車内でメンバーのおろしうり君から<a href="https://code.google.com/p/tesseract-ocr/">Tesseract</a>というのを教えてもらっていたのでこれを使って認識させたところ、80件くらいのCAPTCHA画像に対して12%くらいの精度で正解を出せることがわかった。</p>

<p>今回のCAPTCHA画像の特徴としては、黒背景に赤黒い文字であること、大きさは常に固定されていること、小文字のアルファベットと数字のみが使われていること、左下に必ず<code>nya-</code>という文字が入っていることが挙げられる。<code>nya-</code>の文字の位置は固定なので、読み取りたい画像の部分だけを切り出し（<code>nya-</code>の部分を削る）、さらに二値化することで精度が上がるのではないかと推測し、その加工をしたところ1%精度が向上した。</p>

<p>つらいつらいと思っていたところ実は対応付けデータに不備があることが発覚し、それを直したところ精度は20%になった。</p>

<p>と、いうことは。5回に1回成功するのだから、毎秒5回くらいPOSTすれば1秒に1回はフラグが書ける計算になる。それだけ書ければいいだろうと思って私のpisaは幕を閉じた。<strong>検証もせずに</strong>。</p>

<p>そして2日目。いざ自動POSTスクリプトを起動するとRubyがSEGVで落ちる落ちる。見ればtesseractのネイティブ部分で死にまくっていた。しかも落ちるタイミングがランダム。やってられねえと思って<code>while true; do bundle exec ruby writeflag.rb; done</code>とか打ち込んだ。伝家の宝刀<code>while true</code>である。</p>

<p>ところが全然フラグが書き込めてないので、一応<code>/sec_bbs/board</code>を見に行ったところCAPTCHA画像が複雑化していた。具体的には「線が一本入るようになった」「使う文字種が増えた（＋−÷×＝）」。さすがにこれは無理だろと思って全てを放り投げた。</p>

<p>—完—</p>

<h2>こたえあわせ</h2>

<p>競技終了後、フラグを書き込めていた親方ことwasamusumeのmimura氏に聞きに行ったところ「CAPTCHAは見なきゃキー変わらないよ」みたいなことを言われてその場で膝から崩れ落ちかねないレベルのショックを受けた。そんな簡単な話だったなんて……。</p>

<p>要するに、私が書いたスクリプトのうち、CAPTCHA画像をリクエストしている部分をごっそりコメントアウトすれば爆速でフラグを書き込みまくるスクリプトになっていたわけである。</p>

<p>CAPTCHA画像とセッションが結びついているところは分かっていた（他にキーと対応付ける要素はないので）だけに、何か非常に惜しいというかなんというか。</p>

<p>あと2つめのkeyを全然見つけられないでいたのだが、こちらはどこかの画像に仕込まれていたらしい。</p>
]]></content>
  </entry>
  
</feed>
